import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class ExtensionCronService {
  private readonly logger = new Logger(ExtensionCronService.name);

  constructor(private readonly prisma: PrismaService) {}

  @Cron('0 0 1 * *') // Le 1er de chaque mois √† 00:00
  //@Cron('*/5 * * * *')¬†//¬†Toutes¬†les¬†5¬†minutes
  async updateExtensionsBalance() {
    const startTime = new Date();
    this.logger.log(`üîÑ [CRON MONTHLY] D√©but de la mise √† jour mensuelle des balances des extensions √† ${startTime.toLocaleString()}`);
    
    try {
      // R√©cup√©rer toutes les extensions avec leurs budgets li√©s
      const extensions = await this.prisma.extension.findMany({
        include: {
          budget: true
        }
      });
      
      this.logger.log(`üìä [CRON] Trouv√© ${extensions.length} extensions √† mettre √† jour`);
      
      if (extensions.length === 0) {
        this.logger.warn('‚ö†Ô∏è [CRON] Aucune extension trouv√©e dans la base de donn√©es');
        return;
      }
      
      let updatedCount = 0;
      const defaultBalance = 1000;
      
      // Mettre √† jour chaque extension individuellement avec sa balance sp√©cifique
      for (const extension of extensions) {
        let newBalance: number;
        
        if (extension.budget && extension.budget.amount) {
          // Utiliser la balance du budget li√©
          newBalance = parseFloat(extension.budget.amount.toString());
          this.logger.log(`üí∞ [CRON] Extension ${extension.id}: Balance mise √† jour depuis le budget ${extension.budget.label} (${newBalance})`);
        } else {
          // Pas de budget li√©, utiliser la balance par d√©faut
          newBalance = defaultBalance;
          this.logger.log(`üí∞ [CRON] Extension ${extension.id}: Pas de budget li√©, balance par d√©faut (${newBalance})`);
        }
        
        await this.prisma.extension.update({
          where: { id: extension.id },
          data: { balance: newBalance }
        });
        
        updatedCount++;
      }
      
      const endTime = new Date();
      const duration = endTime.getTime() - startTime.getTime();
      
      this.logger.log(`‚úÖ [CRON MONTHLY] Mise √† jour mensuelle termin√©e en ${duration}ms: ${updatedCount} extensions mises √† jour`);
      
    } catch (error) {
      this.logger.error('‚ùå [CRON] Erreur lors de la mise √† jour des balances des extensions:', error);
    }
  }
}
